import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { 
  getAuth, 
  signInWithEmailAndPassword, 
  createUserWithEmailAndPassword, 
  updateProfile, 
  onAuthStateChanged,
  signOut,
  signInWithCustomToken
} from 'firebase/auth';
import { 
  getFirestore, 
  doc, 
  setDoc, 
  collection, 
  query, 
  where, 
  onSnapshot, 
  getDocs, 
  addDoc, 
  serverTimestamp,
  orderBy,
  limit
} from 'firebase/firestore';
import { 
  LogOut, 
  Droplets, 
  User, 
  Lock, 
  ArrowRight, 
  Sparkles, 
  Mail, 
  Settings, 
  MessageSquare, 
  Users, 
  Search, 
  Plus, 
  Send,
  CornerDownLeft,
  ChevronLeft
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

// --- КОНФИГУРАЦИЯ FIREBASE & INIT ---
const getFirebaseConfig = () => {
  if (typeof __firebase_config !== 'undefined') {
    return JSON.parse(__firebase_config);
  } else {
    return {}; 
  }
};

const app = initializeApp(getFirebaseConfig());
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'liquid-mess-default';

// Utility function to generate a consistent 1-on-1 chat ID
const getPrivateChatId = (uid1, uid2) => {
  const sortedUids = [uid1, uid2].sort();
  return sortedUids.join('_');
};

// --- СЛУЖЕБНЫЕ ФУНКЦИИ FIREBASE ---

// 1. Индексация никнейма для поиска
const indexUserMetadata = async (user) => {
  if (!user || !user.displayName) return;
  const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users_metadata', user.uid);
  try {
    await setDoc(userRef, {
      uid: user.uid,
      nickname: user.displayName.toLowerCase(), // Храним в нижнем регистре для поиска
      originalNickname: user.displayName,
      email: user.email,
    }, { merge: true });
  } catch (e) {
    console.error("Ошибка индексации пользователя: ", e);
  }
};

// 2. Создание 1-на-1 чата (если не существует)
const createOrNavigateToPrivateChat = async (currentUser, targetUser) => {
    const chatId = getPrivateChatId(currentUser.uid, targetUser.uid);
    const chatRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId);
    
    // Создаем метаданные чата (включая имя)
    await setDoc(chatRef, {
        id: chatId,
        type: 'private',
        members: [currentUser.uid, targetUser.uid],
        memberNames: {
            [currentUser.uid]: currentUser.displayName,
            [targetUser.uid]: targetUser.originalNickname // Используем оригинальный ник из поиска
        },
        lastMessage: '',
        updatedAt: serverTimestamp(),
    }, { merge: true });

    return { id: chatId, type: 'private', name: targetUser.originalNickname, targetId: targetUser.uid };
};


// --- ВСПОМОГАТЕЛЬНЫЕ КОМПОНЕНТЫ UI ---

// Анимированный фон
const LiquidBackground = () => (
  <div className="fixed inset-0 overflow-hidden bg-slate-900 -z-10">
    <motion.div 
      animate={{ 
        x: [0, 100, -50, 0], 
        y: [0, -50, 100, 0], 
        scale: [1, 1.2, 0.8, 1] 
      }}
      transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
      className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] bg-purple-600 rounded-full mix-blend-multiply filter blur-[100px] opacity-70"
    />
    <motion.div 
      animate={{ 
        x: [0, -100, 50, 0], 
        y: [0, 100, -50, 0], 
        scale: [1, 1.5, 0.9, 1] 
      }}
      transition={{ duration: 15, repeat: Infinity, ease: "linear" }}
      className="absolute top-[20%] right-[-10%] w-[400px] h-[400px] bg-blue-600 rounded-full mix-blend-multiply filter blur-[100px] opacity-70"
    />
    <motion.div 
      animate={{ 
        x: [0, 50, -100, 0], 
        y: [0, -100, 50, 0], 
        scale: [1, 0.8, 1.2, 1] 
      }}
      transition={{ duration: 18, repeat: Infinity, ease: "linear" }}
      className="absolute bottom-[-10%] left-[20%] w-[600px] h-[600px] bg-pink-600 rounded-full mix-blend-multiply filter blur-[100px] opacity-70"
    />
  </div>
);

// --- ЭКРАНЫ ---

// Модальное окно для установки/смены Никнейма
const NicknameSetupScreen = ({ user, tempNickname, onError, onClose, onNicknameChange }) => {
  const [nickname, setNickname] = useState(user.displayName || tempNickname || '');
  const [loading, setLoading] = useState(false);
  const isSetup = !user.displayName; 

  const handleSetup = async (e) => {
    e.preventDefault();
    const finalNickname = nickname.trim();
    
    if (!finalNickname) {
      onError("Пожалуйста, придумайте никнейм.");
      return;
    }

    setLoading(true);
    onError('');

    try {
      await updateProfile(user, { displayName: finalNickname });
      await indexUserMetadata(user); // Обновление индекса после смены
      if (onNicknameChange) onNicknameChange();
      onClose(); 
    } catch (err) {
      console.error(err);
      onError("Ошибка сохранения никнейма. Попробуйте снова.");
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50" onClick={isSetup ? null : onClose}>
      <motion.div 
        key="setup-nickname"
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="w-full max-w-md bg-slate-900/90 backdrop-blur-xl border border-white/20 p-8 rounded-3xl shadow-2xl relative overflow-hidden"
        onClick={(e) => e.stopPropagation()} 
      >
        <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-yellow-500 via-pink-500 to-red-500" />
        
        <div className="flex flex-col items-center mb-8">
          <Settings size={40} className="text-white mb-2" />
          <h1 className="text-2xl font-bold text-white tracking-tight">
            {isSetup ? "Придумайте Никнейм" : "Изменить Никнейм"}
          </h1>
          <p className="text-blue-200 mt-2 text-sm uppercase tracking-widest opacity-80">
            {isSetup ? "Обязательный шаг для начала" : "Ваши настройки профиля"}
          </p>
        </div>

        <form onSubmit={handleSetup} className="space-y-6">
            <div className="relative group">
                <User className="absolute left-4 top-1/2 -translate-y-1/2 text-white/50 group-focus-within:text-white transition-colors" size={20} />
                <input
                    type="text"
                    placeholder="Ваш Никнейм"
                    value={nickname}
                    onChange={(e) => setNickname(e.target.value)}
                    className="w-full bg-black/20 border border-white/10 rounded-2xl py-4 pl-12 pr-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                    required
                />
            </div>
            
            <div className="text-red-300 text-sm text-center h-5">{onError}</div> 

            <button
                type="submit"
                disabled={loading}
                className="w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white font-bold py-4 rounded-2xl shadow-lg shadow-purple-500/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2"
            >
                {loading ? <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" /> : (
                    <>
                        {isSetup ? "Сохранить и войти" : "Сохранить изменения"} <Sparkles size={20} />
                    </>
                )}
            </button>
            {!isSetup && (
              <button
                type="button"
                onClick={onClose}
                className="w-full text-white/70 hover:text-white mt-2 p-2 transition-colors"
              >
                Отмена
              </button>
            )}
        </form>
      </motion.div>
    </div>
  );
};

// Экран входа/регистрации (Добро пожаловать)
const AuthScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [nickname, setNickname] = useState(''); 
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  // Логика попытки регистрации
  const attemptRegistration = async () => {
    const finalNickname = nickname.trim();
    if (!finalNickname) {
      setError("Аккаунт не найден. Для регистрации придумайте никнейм.");
      throw new Error("Missing nickname for registration");
    }
    
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      // Устанавливаем никнейм сразу после регистрации
      await updateProfile(userCredential.user, { displayName: finalNickname });
      await indexUserMetadata(userCredential.user); // Индексируем нового пользователя
    } catch (err) {
      console.error(err);
      let msg = "Ошибка регистрации.";
      if (err.code === 'auth/email-already-in-use') msg = "Эта почта уже занята!";
      if (err.code === 'auth/weak-password') msg = "Пароль слишком простой (мин. 6 символов).";
      if (err.code === 'auth/operation-not-allowed') msg = "Ошибка: Email/Password вход не включен в настройках Firebase.";
      setError(msg);
      throw err; 
    }
  };

  // Логика основной формы (вход или регистрация)
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      // 1. Попытка входа
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      await indexUserMetadata(userCredential.user); // Обновляем индекс при входе
      
    } catch (err) {
      // 2. Если вход не удался - пробуем зарегистрировать
      if (err.code === 'auth/user-not-found' || err.code === 'auth/invalid-credential') {
        try {
          await attemptRegistration();
        } catch (regError) {
          // Ошибки регистрации уже обработаны внутри attemptRegistration
        }
      } else {
        // Другие ошибки
        console.error(err);
        let msg = "Ошибка входа.";
        if (err.code === 'auth/wrong-password') msg = "Неверный пароль.";
        if (err.code === 'auth/invalid-email') msg = "Некорректный формат почты.";
        if (err.code === 'auth/operation-not-allowed') msg = "Ошибка: Email/Password вход не включен в настройках Firebase.";
        setError(msg);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen p-4">
        <motion.div 
            key="login-form"
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            className="w-full max-w-md bg-white/10 backdrop-blur-xl border border-white/20 p-8 rounded-3xl shadow-2xl relative overflow-hidden"
          >
            <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-purple-500 via-pink-500 to-blue-500" />
            
            <div className="flex flex-col items-center mb-8">
              <div className="bg-white/20 p-4 rounded-full mb-4 shadow-inner ring-1 ring-white/30">
                <Droplets size={40} className="text-white" />
              </div>
              <h1 className="text-4xl font-bold text-white tracking-tight">Liquid Mess</h1>
              <p className="text-blue-200 mt-2 text-sm uppercase tracking-widest opacity-80">
                Добро пожаловать! Войдите или Зарегистрируйтесь
              </p>
            </div>

            <form onSubmit={handleSubmit} className="space-y-4">
              
              <div className="relative group">
                <Mail className="absolute left-4 top-1/2 -translate-y-1/2 text-white/50 group-focus-within:text-white transition-colors" size={20} />
                <input
                  type="email"
                  placeholder="Email (почта)"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full bg-black/20 border border-white/10 rounded-2xl py-4 pl-12 pr-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                  required
                />
              </div>

              <div className="relative group">
                <Lock className="absolute left-4 top-1/2 -translate-y-1/2 text-white/50 group-focus-within:text-white transition-colors" size={20} />
                <input
                  type="password"
                  placeholder="Пароль"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full bg-black/20 border border-white/10 rounded-2xl py-4 pl-12 pr-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                  required
                />
              </div>
              
              <div className="relative group">
                <User className="absolute left-4 top-1/2 -translate-y-1/2 text-white/50 group-focus-within:text-white transition-colors" size={20} />
                <input
                  type="text"
                  placeholder="Никнейм (только для регистрации)"
                  value={nickname}
                  onChange={(e) => setNickname(e.target.value)}
                  className="w-full bg-black/20 border border-white/10 rounded-2xl py-4 pl-12 pr-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                />
              </div>

              {error && (
                <motion.div 
                  initial={{ opacity: 0, y: -10 }}
                  animate={{ opacity: 1, y: 0 }}
                  className="text-red-300 text-sm text-center bg-red-500/20 py-2 rounded-lg border border-red-500/30"
                >
                  {error}
                </motion.div>
              )}

              <button
                type="submit"
                disabled={loading}
                className="w-full mt-4 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-4 rounded-2xl shadow-lg shadow-purple-500/30 transition-all transform hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2"
              >
                {loading ? <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" /> : (
                  <>
                    Войти или Зарегистрироваться <ArrowRight size={20} />
                  </>
                )}
              </button>
            </form>
        </motion.div>
    </div>
  );
};

// Экран приветствия после входа (с кнопкой "Войти" в чаты)
const WelcomeUserScreen = ({ user, setScreen, setShowSettings }) => {
  return (
    <div className="flex items-center justify-center min-h-screen p-4">
      <motion.div 
        key="welcome-user"
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="w-full max-w-md bg-white/10 backdrop-blur-xl border border-white/20 p-10 rounded-3xl shadow-2xl relative text-center"
      >
        <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-green-400 via-cyan-400 to-blue-400" />

        <div className="flex flex-col items-center mb-8">
            <div className="w-16 h-16 rounded-full bg-gradient-to-tr from-cyan-400 to-blue-500 flex items-center justify-center text-white font-extrabold text-3xl shadow-xl mb-4">
                {(user.displayName?.[0] || user.email?.[0])?.toUpperCase()}
            </div>
            <h1 className="text-3xl font-bold text-white tracking-tight">
                Добро пожаловать, {user.displayName}!
            </h1>
            <p className="text-blue-200 mt-2 text-base">
                Вы успешно авторизованы.
            </p>
        </div>

        <div className='flex flex-col gap-3 mt-6'>
          {/* Кнопка "Войти" в чаты */}
          <button 
            onClick={() => setScreen('chatList')}
            className="w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white font-bold py-3 rounded-xl shadow-lg shadow-purple-500/30 transition-all transform hover:scale-[1.01] active:scale-[0.99] flex items-center justify-center gap-2"
            title="Войти в список чатов"
          >
            Войти <ArrowRight size={20} />
          </button>

          {/* Кнопка "Настройки" */}
          <button 
            onClick={() => setShowSettings(true)}
            className="w-full bg-slate-700/50 hover:bg-slate-700/80 text-white font-semibold py-3 rounded-xl transition-all flex items-center justify-center gap-2 border border-white/10"
            title="Настройки профиля"
          >
            <Settings size={20} /> Настройки (Сменить Никнейм)
          </button>
          
          {/* Кнопка "Выход" */}
          <button 
            onClick={() => signOut(auth)}
            className="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 rounded-xl shadow-lg shadow-red-500/30 transition-all flex items-center justify-center gap-2"
            title="Выход"
          >
            <LogOut size={20} /> Выход
          </button>
        </div>
      </motion.div>
    </div>
  );
};

// Экран для отображения сообщений в выбранном чате
const ChatScreen = ({ chat, currentUser, setChat }) => {
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const messagesEndRef = useRef(null);

    // Подписка на сообщения
    useEffect(() => {
        if (!chat || !db) return;

        const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', chat.id, 'messages');
        const q = query(messagesRef, orderBy('createdAt'), limit(100)); // Загружаем последние 100

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const msgs = [];
            snapshot.forEach(doc => msgs.push({ ...doc.data(), id: doc.id }));
            setMessages(msgs);
        }, (error) => {
            console.error("Ошибка получения сообщений:", error);
        });

        return () => unsubscribe();
    }, [chat]);

    // Скролл вниз при получении новых сообщений
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, [messages]);

    // Отправка сообщения
    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (!newMessage.trim() || !chat) return;

        const messageText = newMessage.trim();
        setNewMessage('');

        const messageData = {
            text: messageText,
            createdAt: serverTimestamp(),
            senderId: currentUser.uid,
            senderName: currentUser.displayName,
        };

        try {
            const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', chat.id, 'messages');
            await addDoc(messagesRef, messageData);

            // Обновляем метаданные чата
            const chatRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chat.id);
            await setDoc(chatRef, {
                lastMessage: messageText,
                updatedAt: serverTimestamp(),
            }, { merge: true });

        } catch (error) {
            console.error("Ошибка отправки сообщения:", error);
        }
    };
    
    // Получение имени собеседника
    const chatName = useMemo(() => {
        if (chat.type === 'private') {
            return chat.memberNames[chat.targetId] || 'Собеседник';
        }
        return chat.name;
    }, [chat]);

    return (
        <div className="flex flex-col h-screen max-w-4xl mx-auto md:p-6">
            <motion.div 
                initial={{ x: '100%' }}
                animate={{ x: 0 }}
                exit={{ x: '100%' }}
                transition={{ type: "tween", duration: 0.3 }}
                className="flex-1 bg-black/40 md:bg-white/5 md:backdrop-blur-xl md:border md:border-white/10 md:rounded-3xl flex flex-col overflow-hidden relative shadow-2xl"
            >
                {/* Хедер чата */}
                <div className="p-4 border-b border-white/10 bg-white/5 backdrop-blur-md sticky top-0 z-10 flex items-center">
                    <button onClick={() => setChat(null)} className="p-2 hover:bg-white/10 rounded-full text-white/80 transition-colors mr-3">
                        <ChevronLeft size={24} />
                    </button>
                    <div className="flex flex-col">
                        <h2 className="text-white font-bold">{chatName}</h2>
                        <span className="text-xs text-white/50">{chat.type === 'private' ? 'Личный чат' : 'Групповой чат'}</span>
                    </div>
                </div>

                {/* Сообщения */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
                    {messages.map((msg) => (
                        <div key={msg.id} className={`flex ${msg.senderId === currentUser.uid ? 'justify-end' : 'justify-start'}`}>
                            <div 
                                className={`max-w-[80%] p-3 rounded-xl shadow-lg ${
                                    msg.senderId === currentUser.uid 
                                        ? 'bg-purple-600 text-white rounded-br-none' 
                                        : 'bg-slate-700/50 text-white rounded-tl-none'
                                }`}
                            >
                                {msg.senderId !== currentUser.uid && (
                                    <div className="font-semibold text-xs mb-1 text-purple-200">
                                        {msg.senderName || 'Неизвестный'}
                                    </div>
                                )}
                                <p className="text-sm whitespace-pre-wrap">{msg.text}</p>
                                <span className="block text-right text-[10px] opacity-60 mt-1">
                                    {msg.createdAt?.toDate ? msg.createdAt.toDate().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }) : '...'}
                                </span>
                            </div>
                        </div>
                    ))}
                    <div ref={messagesEndRef} />
                </div>

                {/* Ввод сообщения */}
                <form onSubmit={handleSendMessage} className="p-4 bg-white/5 border-t border-white/10 flex">
                    <input
                        type="text"
                        value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        placeholder="Введите сообщение..."
                        className="flex-1 bg-black/20 border border-white/10 text-white placeholder-white/30 rounded-l-xl p-4 focus:outline-none focus:bg-black/40 focus:border-purple-500/50 transition-all"
                    />
                    <button
                        type="submit"
                        disabled={!newMessage.trim()}
                        className="bg-purple-600 hover:bg-purple-500 text-white font-bold px-6 rounded-r-xl shadow-lg shadow-purple-500/30 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                    >
                        <Send size={20} />
                    </button>
                </form>
            </motion.div>
        </div>
    );
};

// Модальное окно создания группы
const CreateGroupModal = ({ currentUser, existingChats, onClose }) => {
    const [groupName, setGroupName] = useState('');
    const [selectedFriends, setSelectedFriends] = useState([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    const handleCreateGroup = async (e) => {
        e.preventDefault();
        if (!groupName.trim()) {
            setError("Введите название группы.");
            return;
        }

        setLoading(true);
        setError('');

        const finalName = groupName.trim();
        const initialMembers = [currentUser.uid];
        
        // ВАЖНО: Согласно требованию, группа появляется ТОЛЬКО у создателя, 
        // поэтому мы добавляем только его, даже если он выбрал друзей.
        // Друзей можно будет добавить позже в UI чата, если они были выбраны.

        try {
            const groupMetadata = {
                name: finalName,
                type: 'group',
                creatorId: currentUser.uid,
                members: initialMembers, // Только создатель
                memberNames: {
                    [currentUser.uid]: currentUser.displayName,
                },
                lastMessage: 'Группа создана.',
                updatedAt: serverTimestamp(),
            };

            const groupsRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats');
            const newGroupRef = await addDoc(groupsRef, groupMetadata);

            // Отправляем первое сообщение
            const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', newGroupRef.id, 'messages');
            await addDoc(messagesRef, {
                text: `Группа "${finalName}" создана пользователем ${currentUser.displayName}.`,
                createdAt: serverTimestamp(),
                senderId: currentUser.uid,
                senderName: 'Система',
            });
            
            // Здесь должна быть логика добавления выбранных друзей в чат, 
            // но для простоты (и чтобы не усложнять UI) оставляем только создателя, 
            // как вы просили, что группа "появится только у создателя".

            onClose();

        } catch (err) {
            console.error(err);
            setError("Ошибка создания группы.");
        } finally {
            setLoading(false);
        }
    };
    
    // Получение списка друзей для выбора (на основе существующих приватных чатов)
    const availableFriends = useMemo(() => {
        return existingChats
            .filter(chat => chat.type === 'private')
            .map(chat => {
                const targetId = chat.members.find(id => id !== currentUser.uid);
                return {
                    uid: targetId,
                    nickname: chat.memberNames[targetId],
                };
            });
    }, [existingChats, currentUser.uid]);


    return (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50" onClick={onClose}>
            <motion.div 
                key="create-group"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                className="w-full max-w-lg bg-slate-900/90 backdrop-blur-xl border border-white/20 p-8 rounded-3xl shadow-2xl relative overflow-hidden"
                onClick={(e) => e.stopPropagation()} 
            >
                <div className="flex justify-between items-center mb-6 border-b border-white/10 pb-3">
                    <h2 className="text-2xl font-bold text-white tracking-tight flex items-center gap-2">
                        <Users size={24} className="text-purple-400" /> Создать Новую Группу
                    </h2>
                    <button onClick={onClose} className="text-white/70 hover:text-white">
                        <CornerDownLeft size={20} />
                    </button>
                </div>
                
                <form onSubmit={handleCreateGroup} className="space-y-6">
                    <div className="relative group">
                        <input
                            type="text"
                            placeholder="Название группы"
                            value={groupName}
                            onChange={(e) => setGroupName(e.target.value)}
                            className="w-full bg-black/20 border border-white/10 rounded-2xl py-3 px-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                            required
                        />
                    </div>

                    <div className="text-red-300 text-sm h-5">{error}</div> 

                    <button
                        type="submit"
                        disabled={loading}
                        className="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-3 rounded-xl shadow-lg shadow-purple-500/30 transition-all disabled:opacity-50 flex items-center justify-center gap-2"
                    >
                        {loading ? <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" /> : (
                            <>
                                Создать Группу (Только для себя) <Plus size={20} />
                            </>
                        )}
                    </button>
                    <p className="text-xs text-white/50 text-center">
                        * Группа будет видна только вам. Друзей можно будет добавить позже.
                    </p>
                </form>
            </motion.div>
        </div>
    );
};


// Экран со списком чатов и поиском друзей
const ChatListScreen = ({ currentUser, setScreen, setChat }) => {
    const [chats, setChats] = useState([]);
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [showCreateGroupModal, setShowCreateGroupModal] = useState(false);

    // 1. Подписка на чаты пользователя
    useEffect(() => {
        if (!currentUser || !db) return;
        
        // Получаем все чаты, где текущий пользователь является членом (поле 'members' содержит его UID)
        const chatsRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats');
        const q = query(chatsRef, where('members', 'array-contains', currentUser.uid), orderBy('updatedAt', 'desc'));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            const chatList = [];
            snapshot.forEach((doc) => {
                const chatData = doc.data();
                let displayName = chatData.name;
                let targetId = null;

                if (chatData.type === 'private') {
                    // Для 1-на-1 чата определяем имя собеседника
                    targetId = chatData.members.find(uid => uid !== currentUser.uid);
                    displayName = chatData.memberNames[targetId] || 'Неизвестный пользователь';
                }
                
                chatList.push({ ...chatData, id: doc.id, name: displayName, targetId: targetId });
            });
            setChats(chatList);
        }, (error) => {
            console.error("Ошибка при получении списка чатов:", error);
        });

        return () => unsubscribe();
    }, [currentUser.uid]);

    // 2. Поиск друзей по никнейму
    const handleSearch = useCallback(async (queryText) => {
        if (queryText.length < 3) {
            setSearchResults([]);
            return;
        }

        setIsSearching(true);
        const qText = queryText.toLowerCase();
        
        try {
            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'users_metadata');
            // Ищем по полю 'nickname' (нижний регистр)
            const q = query(
                usersRef, 
                where('nickname', '>=', qText), 
                where('nickname', '<=', qText + '\uf7ff'), // Юникод для поиска "начинается с"
                limit(10)
            );
            
            const snapshot = await getDocs(q);
            const results = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                // Исключаем текущего пользователя
                if (data.uid !== currentUser.uid) { 
                    results.push(data);
                }
            });
            setSearchResults(results);
        } catch (error) {
            console.error("Ошибка поиска пользователей:", error);
        } finally {
            setIsSearching(false);
        }
    }, [currentUser.uid]);

    // Обновляем поиск при изменении запроса
    useEffect(() => {
        const timeoutId = setTimeout(() => handleSearch(searchQuery), 300);
        return () => clearTimeout(timeoutId);
    }, [searchQuery, handleSearch]);

    // Обработчик нажатия на результат поиска
    const handleStartPrivateChat = async (targetUser) => {
        const chatData = await createOrNavigateToPrivateChat(currentUser, targetUser);
        setChat(chatData); // Переходим в чат
        setSearchQuery(''); // Сбрасываем поиск
        setSearchResults([]);
    };
    
    // Обработчик нажатия на чат в списке
    const handleOpenChat = (chat) => {
        // Устанавливаем целевой ID для удобства в ChatScreen
        if (chat.type === 'private' && !chat.targetId) {
             chat.targetId = chat.members.find(uid => uid !== currentUser.uid);
        }
        setChat(chat);
    };


    return (
        <div className="flex flex-col h-screen max-w-4xl mx-auto md:p-6">
            <motion.div 
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="flex-1 bg-black/40 md:bg-white/5 md:backdrop-blur-xl md:border md:border-white/10 md:rounded-3xl flex flex-col overflow-hidden relative shadow-2xl"
            >
                {/* Хедер и Поиск */}
                <div className="p-4 border-b border-white/10 bg-white/5 backdrop-blur-md sticky top-0 z-10">
                    <div className='flex justify-between items-center mb-4'>
                        <h2 className="text-white text-xl font-bold flex items-center gap-2">
                            <MessageSquare size={20} className="text-pink-400" /> Ваши Чаты
                        </h2>
                        <div className='flex gap-2'>
                            <button 
                                onClick={() => setShowCreateGroupModal(true)}
                                className="p-2 bg-purple-600 hover:bg-purple-500 rounded-xl text-white transition-colors flex items-center gap-1"
                                title="Создать Группу"
                            >
                                <Users size={18} />
                            </button>
                            <button 
                                onClick={() => setScreen('welcome')}
                                className="p-2 hover:bg-white/10 rounded-xl text-white/70 hover:text-white transition-colors"
                                title="Вернуться к приветствию"
                            >
                                <CornerDownLeft size={20} />
                            </button>
                            <button 
                                onClick={() => signOut(auth)}
                                className="p-2 hover:bg-white/10 rounded-xl text-white/70 hover:text-white transition-colors"
                                title="Выход"
                            >
                                <LogOut size={20} />
                            </button>
                        </div>
                    </div>

                    {/* Поиск друзей по никнейму */}
                    <div className="relative">
                        <Search className="absolute left-4 top-1/2 -translate-y-1/2 text-white/50" size={20} />
                        <input
                            type="text"
                            placeholder="Найти друга по никнейму..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className="w-full bg-black/20 border border-white/10 rounded-xl py-3 pl-12 pr-4 text-white placeholder-white/30 focus:outline-none focus:bg-black/30 focus:border-white/30 transition-all"
                        />
                    </div>
                </div>

                {/* Результаты поиска */}
                {searchQuery.length >= 3 && (
                    <div className="absolute top-[120px] left-0 right-0 z-20 bg-slate-800/95 backdrop-blur-lg p-4 shadow-2xl border-b border-white/20">
                        <h3 className="text-sm font-semibold text-purple-300 mb-2">
                            Результаты поиска ({searchResults.length})
                        </h3>
                        {isSearching && <p className="text-white/50">Поиск...</p>}
                        {!isSearching && searchResults.length === 0 && (
                            <p className="text-white/50">Пользователи с никнеймом "{searchQuery}" не найдены.</p>
                        )}
                        {!isSearching && searchResults.map(user => (
                            <motion.div
                                key={user.uid}
                                initial={{ opacity: 0, y: 5 }}
                                animate={{ opacity: 1, y: 0 }}
                                className="flex justify-between items-center p-3 hover:bg-white/10 rounded-lg cursor-pointer transition-colors mt-1"
                                onClick={() => handleStartPrivateChat(user)}
                            >
                                <div className="flex items-center gap-3">
                                    <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white font-bold text-sm">
                                        {user.originalNickname?.[0]?.toUpperCase()}
                                    </div>
                                    <span className="text-white font-semibold">{user.originalNickname}</span>
                                </div>
                                <MessageSquare size={18} className="text-cyan-400" />
                            </motion.div>
                        ))}
                    </div>
                )}

                {/* Список чатов */}
                <div className="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-2">
                    {chats.length === 0 ? (
                        <div className="text-center text-white/50 mt-10">
                            У вас нет активных чатов. Найдите друга по никнейму или создайте группу!
                        </div>
                    ) : (
                        chats.map(chat => (
                            <motion.div
                                key={chat.id}
                                initial={{ opacity: 0, y: 10 }}
                                animate={{ opacity: 1, y: 0 }}
                                onClick={() => handleOpenChat(chat)}
                                className="flex items-center gap-4 p-3 bg-white/10 hover:bg-white/20 rounded-xl cursor-pointer transition-colors border border-white/10"
                            >
                                <div className="w-10 h-10 rounded-full bg-gradient-to-tr from-cyan-400 to-blue-500 flex items-center justify-center text-white font-bold text-lg shadow-md">
                                    {chat.type === 'private' ? chat.name?.[0]?.toUpperCase() : <Users size={20} />}
                                </div>
                                <div className="flex-1 overflow-hidden">
                                    <h3 className="text-white font-semibold truncate">
                                        {chat.name}
                                    </h3>
                                    <p className="text-sm text-white/70 truncate">
                                        {chat.lastMessage || 'Начните чат...'}
                                    </p>
                                </div>
                                <span className="text-xs text-white/50">
                                    {chat.updatedAt?.toDate ? chat.updatedAt.toDate().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }) : '...'}
                                </span>
                            </motion.div>
                        ))
                    )}
                </div>
            </motion.div>

            {/* Модальное окно создания группы */}
            <AnimatePresence>
                {showCreateGroupModal && (
                    <CreateGroupModal
                        currentUser={currentUser}
                        existingChats={chats}
                        onClose={() => setShowCreateGroupModal(false)}
                    />
                )}
            </AnimatePresence>
        </div>
    );
};


// Главный компонент App
const App = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showNicknameSetup, setShowNicknameSetup] = useState(false);
  const [currentScreen, setCurrentScreen] = useState('welcome'); // 'welcome', 'chatList', 'chat'
  const [activeChat, setActiveChat] = useState(null); // { id, name, type, targetId }

  useEffect(() => {
    // 1. Попытка авторизации по токену системы
    const initAuth = async () => {
       if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
         try {
           await signInWithCustomToken(auth, __initial_auth_token);
         } catch (e) {
           console.error("Token auth failed, falling back", e);
         }
       }
    };
    initAuth();

    // 2. Слушатель состояния аутентификации
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
      
      if (currentUser) {
        // Убеждаемся, что метаданные пользователя проиндексированы
        indexUserMetadata(currentUser); 
        
        // Если пользователь авторизован, но никнейм отсутствует, показываем экран настройки
        if (!currentUser.displayName) {
          setShowNicknameSetup(true);
          setCurrentScreen('welcome'); // Возвращаем на приветствие, чтобы показать модалку
        } else if (currentScreen === 'auth') {
          // После успешного входа, если мы на экране auth, переходим на welcome
          setCurrentScreen('welcome');
        }
      } else {
        // Если пользователь вышел, возвращаемся на экран авторизации
        setCurrentScreen('auth');
        setActiveChat(null);
      }
    });

    return () => unsubscribe();
  }, []);

  if (loading) {
    return (
      <div className="h-screen w-screen flex items-center justify-center bg-slate-900 text-white">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-purple-500"></div>
      </div>
    );
  }

  // Принудительный показ настройки никнейма (Модальное окно)
  if (user && showNicknameSetup) {
     return (
        <div className="min-h-screen font-sans text-slate-100 antialiased selection:bg-purple-500 selection:text-white">
            <LiquidBackground />
            <div className="flex items-center justify-center min-h-screen p-4">
              <NicknameSetupScreen 
                  user={user} 
                  tempNickname={user.email?.split('@')[0] || ''}
                  onError={(msg) => console.error(msg)} 
                  onClose={() => setShowNicknameSetup(false)}
                  onNicknameChange={() => setUser({...user, displayName: auth.currentUser.displayName})} // Обновляем локальный стейт
              />
            </div>
        </div>
     );
  }

  const renderScreen = () => {
    if (!user || currentScreen === 'auth') {
        return <AuthScreen key="auth" />;
    }

    if (activeChat) {
        return <ChatScreen key="chat" chat={activeChat} currentUser={user} setChat={setActiveChat} />;
    }

    if (currentScreen === 'chatList') {
        return <ChatListScreen key="chatList" currentUser={user} setScreen={setCurrentScreen} setChat={setActiveChat} />;
    }
    
    // По умолчанию или currentScreen === 'welcome'
    return <WelcomeUserScreen 
        key="welcome" 
        user={user} 
        setScreen={setCurrentScreen} 
        setShowSettings={setShowNicknameSetup} 
    />;
  };

  return (
    <div className="min-h-screen font-sans text-slate-100 antialiased selection:bg-purple-500 selection:text-white">
      <LiquidBackground />
      <AnimatePresence mode='wait'>
        {renderScreen()}
      </AnimatePresence>
      
      {/* Стили для скроллбара */}
      <style>{`
        .custom-scrollbar::-webkit-scrollbar {
          width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
          background: rgba(255, 255, 255, 0.05);
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
          background: rgba(255, 255, 255, 0.2);
          border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
          background: rgba(255, 255, 255, 0.3);
        }
      `}</style>
    </div>
  );
};

export default App;
